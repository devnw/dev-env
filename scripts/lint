#!/usr/bin/env bash
#
# Enhanced multi-language linting script with selective execution and comprehensive configuration.
#
# Supports: Go, JavaScript/TypeScript, Python, Shell, Nix, Zig, SQL, Makefile
# Features: File discovery, selective linter control, configuration management, help system
#

set -euo pipefail

# Default configuration
DEFAULT_CONFIG_DIR="./shared"
DEFAULT_SQL_DIALECT="postgres"
DEFAULT_VERBOSE="false"
DEFAULT_DRY_RUN="false"
DEFAULT_CONTINUE_ON_ERROR="true"

# Get configuration from environment or defaults
CONFIG_DIR="${LINT_CONFIG_DIR:-$DEFAULT_CONFIG_DIR}"
SQL_DIALECT="${SQL_DIALECT:-$DEFAULT_SQL_DIALECT}"
VERBOSE="${LINT_VERBOSE:-$DEFAULT_VERBOSE}"
DRY_RUN="${LINT_DRY_RUN:-$DEFAULT_DRY_RUN}"
CONTINUE_ON_ERROR="${LINT_CONTINUE_ON_ERROR:-$DEFAULT_CONTINUE_ON_ERROR}"

# Linter control variables (can be set via environment or command line)
ENABLE_LICENSE="${LINT_ENABLE_LICENSE:-true}"
ENABLE_MAKEFILE="${LINT_ENABLE_MAKEFILE:-true}"
ENABLE_GO="${LINT_ENABLE_GO:-true}"
ENABLE_JS_TS="${LINT_ENABLE_JS_TS:-true}"
ENABLE_PYTHON="${LINT_ENABLE_PYTHON:-true}"
ENABLE_PYLINT="${LINT_ENABLE_PYLINT:-true}"
ENABLE_SHELL="${LINT_ENABLE_SHELL:-true}"
ENABLE_NIX="${LINT_ENABLE_NIX:-true}"
ENABLE_STATIX="${LINT_ENABLE_STATIX:-true}"
ENABLE_ZIG="${LINT_ENABLE_ZIG:-true}"
ENABLE_SQL="${LINT_ENABLE_SQL:-true}"
ENABLE_SQUAWK="${LINT_ENABLE_SQUAWK:-true}"
ENABLE_YAML="${LINT_ENABLE_YAML:-true}"
ENABLE_JSON="${LINT_ENABLE_JSON:-true}"
ENABLE_OPENAPI="${LINT_ENABLE_OPENAPI:-true}"
ENABLE_PRETTIER="${LINT_ENABLE_PRETTIER:-true}"

# File discovery variables
TARGET_FILES=()
FOUND_GO_FILES=()
FOUND_JS_TS_FILES=()
FOUND_PYTHON_FILES=()
FOUND_SHELL_FILES=()
FOUND_NIX_FILES=()
FOUND_ZIG_FILES=()
FOUND_SQL_FILES=()
FOUND_YAML_FILES=()
FOUND_JSON_FILES=()
FOUND_OPENAPI_FILES=()

# Statistics
RUN_COUNT=0
SUCCESS_COUNT=0
ERROR_COUNT=0
SKIP_COUNT=0

show_help() {
    cat << 'EOF'
lint - Enhanced Multi-Language Linting Tool

USAGE:
    lint [OPTIONS] [files...]

DESCRIPTION:
    Comprehensive linting tool that automatically discovers and lints source files
    across multiple languages with configurable execution and detailed reporting.

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output with detailed execution info
    -n, --dry-run           Show what would be linted without executing
    -c, --continue          Continue on errors (default: true)
    -s, --stop-on-error     Stop on first error (opposite of --continue)
    
    --config-dir DIR        Configuration directory (default: ./shared)
    --sql-dialect DIALECT   SQL dialect for sqlfluff (default: postgres)
    
LINTER CONTROL:
    --disable-all           Disable all linters (use with specific --enable-*)
    --disable-license       Disable license header checking
    --disable-makefile      Disable Makefile linting
    --disable-go            Disable Go linting
    --disable-js-ts         Disable JavaScript/TypeScript linting
    --disable-python        Disable Python linting (flake8)
    --disable-pylint        Disable Python linting (pylint)
    --disable-shell         Disable shell script linting
    --disable-nix           Disable Nix file linting
    --disable-statix        Disable advanced Nix linting
    --disable-zig           Disable Zig linting
    --disable-sql           Disable SQL linting
    --disable-squawk        Disable PostgreSQL-specific SQL linting
    --disable-yaml          Disable YAML linting
    --disable-json          Disable JSON linting
    --disable-openapi       Disable OpenAPI/Swagger linting
    --disable-prettier      Disable Prettier formatting
    
    --enable-license        Enable license header checking
    --enable-makefile       Enable Makefile linting
    --enable-go             Enable Go linting
    --enable-js-ts          Enable JavaScript/TypeScript linting
    --enable-python         Enable Python linting (flake8)
    --enable-pylint         Enable Python linting (pylint)
    --enable-shell          Enable shell script linting
    --enable-nix            Enable Nix file linting
    --enable-statix         Enable advanced Nix linting
    --enable-zig            Enable Zig linting
    --enable-sql            Enable SQL linting
    --enable-squawk         Enable PostgreSQL-specific SQL linting
    --enable-yaml           Enable YAML linting
    --enable-json           Enable JSON linting
    --enable-openapi        Enable OpenAPI/Swagger linting
    --enable-prettier       Enable Prettier formatting

EXAMPLES:
    # Lint all discovered files
    lint
    
    # Verbose output with dry run
    lint -v -n
    
    # Only lint specific files
    lint src/main.go src/utils.py
    
    # Disable Python linters, enable only Go
    lint --disable-python --disable-pylint
    
    # Quick Go-only linting
    lint --disable-all --enable-go
    
    # Custom configuration
    lint --config-dir ./custom-config --sql-dialect mysql

FILE DISCOVERY:
    The tool automatically discovers files in the current directory and subdirectories:
    - Go: *.go files (requires go.mod)
    - JavaScript/TypeScript: *.js, *.jsx, *.ts, *.tsx
    - Python: *.py files
    - Shell: *.sh files
    - Nix: *.nix files
    - Zig: *.zig files
    - SQL: *.sql files
    - YAML: *.yml, *.yaml files
    - JSON: *.json files
    - OpenAPI: openapi.*, swagger.*, api.* (yml/yaml/json)
    - Makefile: Makefile, *.mk files

ENVIRONMENT VARIABLES:
    LINT_CONFIG_DIR              Configuration directory
    LINT_VERBOSE                 Enable verbose output (true/false)
    LINT_DRY_RUN                 Enable dry run mode (true/false)
    LINT_CONTINUE_ON_ERROR       Continue on errors (true/false)
    LINT_ENABLE_*                Enable specific linters (true/false)
    SQL_DIALECT                  SQL dialect for sqlfluff

CONFIGURATION FILES:
    The tool looks for configuration files in the config directory:
    - .golangci.yml              Go linting configuration
    - .eslintrc.json             JavaScript/TypeScript configuration
    - .prettierrc.yaml           Code formatting configuration
    - .sqlfluff                  SQL linting configuration
    - .squawk                    PostgreSQL linting configuration

EXIT CODES:
    0    All enabled linters completed successfully
    1    One or more linters found issues or failed
    2    Invalid command line arguments
    3    Required tools not found

EOF
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[VERBOSE] $*" >&2
    fi
}

log_info() {
    echo "[INFO] $*"
}

log_warn() {
    echo "[WARN] $*" >&2
}

log_error() {
    echo "[ERROR] $*" >&2
}

log_dry_run() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY-RUN] Would execute: $*"
        return 0
    fi
    return 1
}

execute_linter() {
    local name="$1"
    local cmd="$2"
    
    ((RUN_COUNT++))
    
    if log_dry_run "$name: $cmd"; then
        ((SUCCESS_COUNT++))
        return 0
    fi
    
    log_verbose "Executing $name: $cmd"
    
    if eval "$cmd"; then
        log_verbose "$name completed successfully"
        ((SUCCESS_COUNT++))
        return 0
    else
        local exit_code=$?
        log_error "$name failed with exit code $exit_code"
        ((ERROR_COUNT++))
        
        if [[ "$CONTINUE_ON_ERROR" != "true" ]]; then
            log_error "Stopping due to error (use --continue to continue on errors)"
            exit 1
        fi
        return $exit_code
    fi
}

skip_linter() {
    local name="$1"
    local reason="$2"
    
    log_verbose "Skipping $name: $reason"
    ((SKIP_COUNT++))
}

discover_files() {
    log_verbose "Discovering files in current directory and subdirectories..."
    
    # Clear arrays
    FOUND_GO_FILES=()
    FOUND_JS_TS_FILES=()
    FOUND_PYTHON_FILES=()
    FOUND_SHELL_FILES=()
    FOUND_NIX_FILES=()
    FOUND_ZIG_FILES=()
    FOUND_SQL_FILES=()
    FOUND_YAML_FILES=()
    FOUND_JSON_FILES=()
    FOUND_OPENAPI_FILES=()
    
    # Discover Go files (only if go.mod exists)
    if [[ -f "go.mod" ]]; then
        while IFS= read -r -d '' file; do
            FOUND_GO_FILES+=("$file")
        done < <(find . -name "*.go" -type f -not -path "*/vendor/*" -not -path "*/.git/*" -print0)
    fi
    
    # Discover JavaScript/TypeScript files
    while IFS= read -r -d '' file; do
        FOUND_JS_TS_FILES+=("$file")
    done < <(find . \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" \) -type f -not -path "*/node_modules/*" -not -path "*/.git/*" -print0)
    
    # Discover Python files
    while IFS= read -r -d '' file; do
        FOUND_PYTHON_FILES+=("$file")
    done < <(find . -name "*.py" -type f -not -path "*/__pycache__/*" -not -path "*/.git/*" -print0)
    
    # Discover Shell files
    while IFS= read -r -d '' file; do
        FOUND_SHELL_FILES+=("$file")
    done < <(find . -name "*.sh" -type f -not -path "*/.git/*" -print0)
    
    # Discover Nix files
    while IFS= read -r -d '' file; do
        FOUND_NIX_FILES+=("$file")
    done < <(find . -name "*.nix" -type f -not -path "*/.git/*" -print0)
    
    # Discover Zig files
    while IFS= read -r -d '' file; do
        FOUND_ZIG_FILES+=("$file")
    done < <(find . -name "*.zig" -type f -not -path "*/.git/*" -print0)
    
    # Discover SQL files
    while IFS= read -r -d '' file; do
        FOUND_SQL_FILES+=("$file")
    done < <(find . -name "*.sql" -type f -not -path "*/.git/*" -print0)
    
    # Discover YAML files
    while IFS= read -r -d '' file; do
        FOUND_YAML_FILES+=("$file")
    done < <(find . \( -name "*.yml" -o -name "*.yaml" \) -type f -not -path "*/.git/*" -print0)
    
    # Discover JSON files
    while IFS= read -r -d '' file; do
        FOUND_JSON_FILES+=("$file")
    done < <(find . -name "*.json" -type f -not -path "*/node_modules/*" -not -path "*/.git/*" -print0)
    
    # Discover OpenAPI/Swagger files
    while IFS= read -r -d '' file; do
        FOUND_OPENAPI_FILES+=("$file")
    done < <(find . \( -name "openapi.*" -o -name "swagger.*" -o -name "api.*" \) -type f \( -name "*.yml" -o -name "*.yaml" -o -name "*.json" \) -not -path "*/.git/*" -print0)
    
    log_verbose "File discovery complete:"
    log_verbose "  Go files: ${#FOUND_GO_FILES[@]}"
    log_verbose "  JS/TS files: ${#FOUND_JS_TS_FILES[@]}"
    log_verbose "  Python files: ${#FOUND_PYTHON_FILES[@]}"
    log_verbose "  Shell files: ${#FOUND_SHELL_FILES[@]}"
    log_verbose "  Nix files: ${#FOUND_NIX_FILES[@]}"
    log_verbose "  Zig files: ${#FOUND_ZIG_FILES[@]}"
    log_verbose "  SQL files: ${#FOUND_SQL_FILES[@]}"
    log_verbose "  YAML files: ${#FOUND_YAML_FILES[@]}"
    log_verbose "  JSON files: ${#FOUND_JSON_FILES[@]}"
    log_verbose "  OpenAPI files: ${#FOUND_OPENAPI_FILES[@]}"
}

filter_target_files() {
    if [[ ${#TARGET_FILES[@]} -eq 0 ]]; then
        return 0  # No filtering needed
    fi
    
    log_verbose "Filtering discovered files based on target list..."
    
    # Filter each array to only include target files
    local filtered_go=()
    local filtered_js_ts=()
    local filtered_python=()
    local filtered_shell=()
    local filtered_nix=()
    local filtered_zig=()
    local filtered_sql=()
    
    # Helper function to check if file is in target list
    is_target_file() {
        local file="$1"
        local target
        for target in "${TARGET_FILES[@]}"; do
            if [[ "$file" == "$target" ]] || [[ "$(realpath "$file" 2>/dev/null || echo "$file")" == "$(realpath "$target" 2>/dev/null || echo "$target")" ]]; then
                return 0
            fi
        done
        return 1
    }
    
    # Filter arrays
    for file in "${FOUND_GO_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_go+=("$file")
        fi
    done
    
    for file in "${FOUND_JS_TS_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_js_ts+=("$file")
        fi
    done
    
    for file in "${FOUND_PYTHON_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_python+=("$file")
        fi
    done
    
    for file in "${FOUND_SHELL_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_shell+=("$file")
        fi
    done
    
    for file in "${FOUND_NIX_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_nix+=("$file")
        fi
    done
    
    for file in "${FOUND_ZIG_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_zig+=("$file")
        fi
    done
    
    for file in "${FOUND_SQL_FILES[@]}"; do
        if is_target_file "$file"; then
            filtered_sql+=("$file")
        fi
    done
    
    # Update arrays
    FOUND_GO_FILES=("${filtered_go[@]}")
    FOUND_JS_TS_FILES=("${filtered_js_ts[@]}")
    FOUND_PYTHON_FILES=("${filtered_python[@]}")
    FOUND_SHELL_FILES=("${filtered_shell[@]}")
    FOUND_NIX_FILES=("${filtered_nix[@]}")
    FOUND_ZIG_FILES=("${filtered_zig[@]}")
    FOUND_SQL_FILES=("${filtered_sql[@]}")
    
    log_verbose "Filtered file counts:"
    log_verbose "  Go files: ${#FOUND_GO_FILES[@]}"
    log_verbose "  JS/TS files: ${#FOUND_JS_TS_FILES[@]}"
    log_verbose "  Python files: ${#FOUND_PYTHON_FILES[@]}"
    log_verbose "  Shell files: ${#FOUND_SHELL_FILES[@]}"
    log_verbose "  Nix files: ${#FOUND_NIX_FILES[@]}"
    log_verbose "  Zig files: ${#FOUND_ZIG_FILES[@]}"
    log_verbose "  SQL files: ${#FOUND_SQL_FILES[@]}"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE="true"
            shift
            ;;
        -n|--dry-run)
            DRY_RUN="true"
            shift
            ;;
        -c|--continue)
            CONTINUE_ON_ERROR="true"
            shift
            ;;
        -s|--stop-on-error)
            CONTINUE_ON_ERROR="false"
            shift
            ;;
        --config-dir)
            CONFIG_DIR="$2"
            shift 2
            ;;
        --sql-dialect)
            SQL_DIALECT="$2"
            shift 2
            ;;
        --disable-all)
            ENABLE_LICENSE="false"
            ENABLE_MAKEFILE="false"
            ENABLE_GO="false"
            ENABLE_JS_TS="false"
            ENABLE_PYTHON="false"
            ENABLE_PYLINT="false"
            ENABLE_SHELL="false"
            ENABLE_NIX="false"
            ENABLE_STATIX="false"
            ENABLE_ZIG="false"
            ENABLE_SQL="false"
            ENABLE_SQUAWK="false"
            ENABLE_YAML="false"
            ENABLE_JSON="false"
            ENABLE_OPENAPI="false"
            ENABLE_PRETTIER="false"
            shift
            ;;
        --disable-license) ENABLE_LICENSE="false"; shift ;;
        --disable-makefile) ENABLE_MAKEFILE="false"; shift ;;
        --disable-go) ENABLE_GO="false"; shift ;;
        --disable-js-ts) ENABLE_JS_TS="false"; shift ;;
        --disable-python) ENABLE_PYTHON="false"; shift ;;
        --disable-pylint) ENABLE_PYLINT="false"; shift ;;
        --disable-shell) ENABLE_SHELL="false"; shift ;;
        --disable-nix) ENABLE_NIX="false"; shift ;;
        --disable-statix) ENABLE_STATIX="false"; shift ;;
        --disable-zig) ENABLE_ZIG="false"; shift ;;
        --disable-sql) ENABLE_SQL="false"; shift ;;
        --disable-squawk) ENABLE_SQUAWK="false"; shift ;;
        --disable-yaml) ENABLE_YAML="false"; shift ;;
        --disable-json) ENABLE_JSON="false"; shift ;;
        --disable-openapi) ENABLE_OPENAPI="false"; shift ;;
        --disable-prettier) ENABLE_PRETTIER="false"; shift ;;
        --enable-license) ENABLE_LICENSE="true"; shift ;;
        --enable-makefile) ENABLE_MAKEFILE="true"; shift ;;
        --enable-go) ENABLE_GO="true"; shift ;;
        --enable-js-ts) ENABLE_JS_TS="true"; shift ;;
        --enable-python) ENABLE_PYTHON="true"; shift ;;
        --enable-pylint) ENABLE_PYLINT="true"; shift ;;
        --enable-shell) ENABLE_SHELL="true"; shift ;;
        --enable-nix) ENABLE_NIX="true"; shift ;;
        --enable-statix) ENABLE_STATIX="true"; shift ;;
        --enable-zig) ENABLE_ZIG="true"; shift ;;
        --enable-sql) ENABLE_SQL="true"; shift ;;
        --enable-squawk) ENABLE_SQUAWK="true"; shift ;;
        --enable-yaml) ENABLE_YAML="true"; shift ;;
        --enable-json) ENABLE_JSON="true"; shift ;;
        --enable-openapi) ENABLE_OPENAPI="true"; shift ;;
        --enable-prettier) ENABLE_PRETTIER="true"; shift ;;
        -*)
            log_error "Unknown option: $1"
            echo "Use -h or --help for usage information." >&2
            exit 2
            ;;
        *)
            TARGET_FILES+=("$1")
            shift
            ;;
    esac
done

# Display configuration if verbose
if [[ "$VERBOSE" == "true" ]]; then
    log_verbose "Configuration:"
    log_verbose "  Config directory: $CONFIG_DIR"
    log_verbose "  SQL dialect: $SQL_DIALECT"
    log_verbose "  Dry run: $DRY_RUN"
    log_verbose "  Continue on error: $CONTINUE_ON_ERROR"
    log_verbose "  Target files: ${#TARGET_FILES[@]}"
fi

# Discover files
discover_files
filter_target_files

log_info "Starting lint process..."

# License check
if [[ "$ENABLE_LICENSE" == "true" ]]; then
    if command -v license >/dev/null 2>&1; then
        execute_linter "License Check" "license"
    else
        skip_linter "License Check" "license command not available"
    fi
else
    skip_linter "License Check" "disabled"
fi

# Makefile linting
if [[ "$ENABLE_MAKEFILE" == "true" ]]; then
    if command -v checkmake >/dev/null 2>&1; then
        if [[ -f "Makefile" ]] || find . -name "*.mk" -type f | head -1 | grep -q .; then
            execute_linter "Makefile Check" "checkmake Makefile 2>/dev/null || find . -name '*.mk' -type f -exec checkmake {} +"
        else
            skip_linter "Makefile Check" "no Makefile or *.mk files found"
        fi
    else
        skip_linter "Makefile Check" "checkmake command not available"
    fi
else
    skip_linter "Makefile Check" "disabled"
fi

# Go linting
if [[ "$ENABLE_GO" == "true" ]]; then
    if [[ ${#FOUND_GO_FILES[@]} -gt 0 ]]; then
        if command -v golangci-lint >/dev/null 2>&1; then
            local go_config=""
            if [[ -f "$CONFIG_DIR/.golangci.yml" ]]; then
                go_config="--config \"$CONFIG_DIR/.golangci.yml\""
            fi
            execute_linter "Go Linting" "golangci-lint run --fix $go_config"
        else
            skip_linter "Go Linting" "golangci-lint command not available"
        fi
    else
        skip_linter "Go Linting" "no Go files found"
    fi
else
    skip_linter "Go Linting" "disabled"
fi

# JavaScript/TypeScript linting
if [[ "$ENABLE_JS_TS" == "true" ]]; then
    if [[ ${#FOUND_JS_TS_FILES[@]} -gt 0 ]]; then
        if command -v eslint >/dev/null 2>&1; then
            local eslint_config=""
            local file_list=""
            
            # Build file list for targeted linting
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                file_list="${FOUND_JS_TS_FILES[*]}"
            else
                file_list="."
            fi
            
            if [[ -f "$CONFIG_DIR/.eslintrc.json" ]]; then
                eslint_config="--config \"$CONFIG_DIR/.eslintrc.json\""
            fi
            
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "JavaScript/TypeScript Linting" "eslint --fix $eslint_config ${FOUND_JS_TS_FILES[*]}"
            else
                execute_linter "JavaScript/TypeScript Linting" "eslint --fix $eslint_config --ext .js,.jsx,.ts,.tsx ."
            fi
        else
            skip_linter "JavaScript/TypeScript Linting" "eslint command not available"
        fi
    else
        skip_linter "JavaScript/TypeScript Linting" "no JavaScript/TypeScript files found"
    fi
else
    skip_linter "JavaScript/TypeScript Linting" "disabled"
fi

# Python linting (flake8)
if [[ "$ENABLE_PYTHON" == "true" ]]; then
    if [[ ${#FOUND_PYTHON_FILES[@]} -gt 0 ]]; then
        if command -v flake8 >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "Python Linting (flake8)" "flake8 ${FOUND_PYTHON_FILES[*]}"
            else
                execute_linter "Python Linting (flake8)" "flake8 ."
            fi
        else
            skip_linter "Python Linting (flake8)" "flake8 command not available"
        fi
    else
        skip_linter "Python Linting (flake8)" "no Python files found"
    fi
else
    skip_linter "Python Linting (flake8)" "disabled"
fi

# Python linting (pylint) 
if [[ "$ENABLE_PYLINT" == "true" ]]; then
    if [[ ${#FOUND_PYTHON_FILES[@]} -gt 0 ]]; then
        if command -v pylint >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "Python Linting (pylint)" "pylint ${FOUND_PYTHON_FILES[*]}"
            else
                execute_linter "Python Linting (pylint)" "find . -name '*.py' -exec pylint {} +"
            fi
        else
            skip_linter "Python Linting (pylint)" "pylint command not available"
        fi
    else
        skip_linter "Python Linting (pylint)" "no Python files found"
    fi
else
    skip_linter "Python Linting (pylint)" "disabled"
fi

# Shell script linting
if [[ "$ENABLE_SHELL" == "true" ]]; then
    if [[ ${#FOUND_SHELL_FILES[@]} -gt 0 ]]; then
        if command -v shellcheck >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "Shell Script Linting" "shellcheck ${FOUND_SHELL_FILES[*]}"
            else
                execute_linter "Shell Script Linting" "find . -name '*.sh' -type f -exec shellcheck {} +"
            fi
        else
            skip_linter "Shell Script Linting" "shellcheck command not available"
        fi
    else
        skip_linter "Shell Script Linting" "no shell scripts found"
    fi
else
    skip_linter "Shell Script Linting" "disabled"
fi

# Nix file linting
if [[ "$ENABLE_NIX" == "true" ]]; then
    if [[ ${#FOUND_NIX_FILES[@]} -gt 0 ]]; then
        if command -v nixfmt >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "Nix Formatting Check" "nixfmt --check ${FOUND_NIX_FILES[*]}"
            else
                execute_linter "Nix Formatting Check" "nixfmt-tree --check ."
            fi
        else
            skip_linter "Nix Formatting Check" "nixfmt command not available"
        fi
    else
        skip_linter "Nix Formatting Check" "no Nix files found"
    fi
else
    skip_linter "Nix Formatting Check" "disabled"
fi

# Advanced Nix linting (statix)
if [[ "$ENABLE_STATIX" == "true" ]]; then
    if [[ ${#FOUND_NIX_FILES[@]} -gt 0 ]]; then
        if command -v statix >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "Advanced Nix Linting (statix)" "statix check ${FOUND_NIX_FILES[*]}"
            else
                execute_linter "Advanced Nix Linting (statix)" "statix check ."
            fi
        else
            skip_linter "Advanced Nix Linting (statix)" "statix command not available"
        fi
    else
        skip_linter "Advanced Nix Linting (statix)" "no Nix files found"
    fi
else
    skip_linter "Advanced Nix Linting (statix)" "disabled"
fi

# Zig linting
if [[ "$ENABLE_ZIG" == "true" ]]; then
    if [[ ${#FOUND_ZIG_FILES[@]} -gt 0 ]]; then
        if command -v zlint >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "Zig Linting" "zlint ${FOUND_ZIG_FILES[*]}"
            else
                execute_linter "Zig Linting" "find . -name '*.zig' -type f -exec zlint {} +"
            fi
        else
            skip_linter "Zig Linting" "zlint command not available"
        fi
    else
        skip_linter "Zig Linting" "no Zig files found"
    fi
else
    skip_linter "Zig Linting" "disabled"
fi

# SQL linting and fixing
if [[ "$ENABLE_SQL" == "true" ]]; then
    if [[ ${#FOUND_SQL_FILES[@]} -gt 0 ]]; then
        if command -v sqlfluff >/dev/null 2>&1; then
            local sqlfluff_config=""
            if [[ -f "$CONFIG_DIR/.sqlfluff" ]]; then
                sqlfluff_config="--config \"$CONFIG_DIR/.sqlfluff\""
            fi
            
            local sql_targets=""
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                sql_targets="${FOUND_SQL_FILES[*]}"
            else
                sql_targets="."
            fi
            
            # First run fix, then lint
            execute_linter "SQL Auto-fix (sqlfluff)" "sqlfluff fix --dialect \"$SQL_DIALECT\" $sqlfluff_config $sql_targets"
            execute_linter "SQL Linting (sqlfluff)" "sqlfluff lint --dialect \"$SQL_DIALECT\" $sqlfluff_config $sql_targets"
        else
            skip_linter "SQL Linting" "sqlfluff command not available"
        fi
    else
        skip_linter "SQL Linting" "no SQL files found"
    fi
else
    skip_linter "SQL Linting" "disabled"
fi

# PostgreSQL-specific SQL linting (squawk)
if [[ "$ENABLE_SQUAWK" == "true" ]]; then
    if [[ "$SQL_DIALECT" == "postgres" ]]; then
        if [[ ${#FOUND_SQL_FILES[@]} -gt 0 ]]; then
            if command -v squawk >/dev/null 2>&1; then
                local squawk_config=""
                if [[ -f "$CONFIG_DIR/.squawk" ]]; then
                    squawk_config="--config \"$CONFIG_DIR/.squawk\""
                fi
                
                local sql_targets=""
                if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                    sql_targets="${FOUND_SQL_FILES[*]}"
                else
                    sql_targets="."
                fi
                
                execute_linter "PostgreSQL SQL Linting (squawk)" "squawk $squawk_config $sql_targets"
            else
                skip_linter "PostgreSQL SQL Linting (squawk)" "squawk command not available"
            fi
        else
            skip_linter "PostgreSQL SQL Linting (squawk)" "no SQL files found"
        fi
    else
        skip_linter "PostgreSQL SQL Linting (squawk)" "SQL dialect is not postgres"
    fi
else
    skip_linter "PostgreSQL SQL Linting (squawk)" "disabled"
fi

# YAML linting
if [[ "$ENABLE_YAML" == "true" ]]; then
    if [[ ${#FOUND_YAML_FILES[@]} -gt 0 ]]; then
        if command -v yamllint >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "YAML Linting" "yamllint ${FOUND_YAML_FILES[*]}"
            else
                execute_linter "YAML Linting" "yamllint ."
            fi
        else
            skip_linter "YAML Linting" "yamllint command not available"
        fi
    else
        skip_linter "YAML Linting" "no YAML files found"
    fi
else
    skip_linter "YAML Linting" "disabled"
fi

# JSON linting and formatting
if [[ "$ENABLE_JSON" == "true" ]]; then
    if [[ ${#FOUND_JSON_FILES[@]} -gt 0 ]]; then
        if command -v jq >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "JSON Validation" "printf '%s\\n' ${FOUND_JSON_FILES[*]} | xargs -I {} jq empty {}"
            else
                execute_linter "JSON Validation" "find . -name '*.json' -not -path '*/node_modules/*' -not -path '*/.git/*' -exec jq empty {} +"
            fi
        else
            skip_linter "JSON Validation" "jq command not available"
        fi
    else
        skip_linter "JSON Validation" "no JSON files found"
    fi
else
    skip_linter "JSON Validation" "disabled"
fi

# OpenAPI/Swagger linting
if [[ "$ENABLE_OPENAPI" == "true" ]]; then
    if [[ ${#FOUND_OPENAPI_FILES[@]} -gt 0 ]]; then
        if command -v redocly >/dev/null 2>&1; then
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                execute_linter "OpenAPI Linting" "redocly lint ${FOUND_OPENAPI_FILES[*]}"
            else
                execute_linter "OpenAPI Linting" "find . \\( -name 'openapi.*' -o -name 'swagger.*' -o -name 'api.*' \\) -type f \\( -name '*.yml' -o -name '*.yaml' -o -name '*.json' \\) -not -path '*/.git/*' -exec redocly lint {} +"
            fi
        else
            skip_linter "OpenAPI Linting" "redocly command not available"
        fi
    else
        skip_linter "OpenAPI Linting" "no OpenAPI files found"
    fi
else
    skip_linter "OpenAPI Linting" "disabled"
fi

# Prettier formatting (for multiple file types)
if [[ "$ENABLE_PRETTIER" == "true" ]]; then
    local prettier_files=()
    prettier_files+=("${FOUND_JS_TS_FILES[@]}")
    prettier_files+=("${FOUND_JSON_FILES[@]}")
    prettier_files+=("${FOUND_YAML_FILES[@]}")
    
    if [[ ${#prettier_files[@]} -gt 0 ]]; then
        if command -v prettier >/dev/null 2>&1; then
            local prettier_config=""
            if [[ -f "$CONFIG_DIR/.prettierrc.yaml" ]]; then
                prettier_config="--config \"$CONFIG_DIR/.prettierrc.yaml\""
            fi
            
            if [[ ${#TARGET_FILES[@]} -gt 0 ]]; then
                # Filter prettier files to only include target files
                local filtered_prettier=()
                for file in "${prettier_files[@]}"; do
                    for target in "${TARGET_FILES[@]}"; do
                        if [[ "$file" == "$target" ]] || [[ "$(realpath "$file" 2>/dev/null || echo "$file")" == "$(realpath "$target" 2>/dev/null || echo "$target")" ]]; then
                            filtered_prettier+=("$file")
                            break
                        fi
                    done
                done
                if [[ ${#filtered_prettier[@]} -gt 0 ]]; then
                    execute_linter "Prettier Formatting" "prettier --write $prettier_config ${filtered_prettier[*]}"
                else
                    skip_linter "Prettier Formatting" "no matching target files"
                fi
            else
                execute_linter "Prettier Formatting" "prettier --write $prettier_config --ignore-path '$CONFIG_DIR/.prettierignore' ."
            fi
        else
            skip_linter "Prettier Formatting" "prettier command not available"
        fi
    else
        skip_linter "Prettier Formatting" "no supported files found (JS/TS/JSON/YAML)"
    fi
else
    skip_linter "Prettier Formatting" "disabled"
fi

# Print summary
log_info "Lint process completed"
log_info "Summary:"
log_info "  Linters run: $RUN_COUNT"
log_info "  Successful: $SUCCESS_COUNT"
log_info "  Failed: $ERROR_COUNT"
log_info "  Skipped: $SKIP_COUNT"

if [[ $DRY_RUN == "true" ]]; then
    log_info "This was a dry run - no actual linting was performed"
fi

# Exit with appropriate code
if [[ $ERROR_COUNT -gt 0 ]]; then
    exit 1
else
    exit 0
fi
